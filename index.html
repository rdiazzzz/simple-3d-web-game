<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ThreeJS player 2022 Models</title>
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css"
      rel="stylesheet"
      integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3"
      crossorigin="anonymous"
    />
  </head>
  <body class="bg-dark">
    <script
      src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"
      integrity="sha384-ka7Sk0Gln4gmtz2MlQnikT1wXgYsOg+OMhuP+IlRH9sENBO0LRn5q+8nbTov4+1p"
      crossorigin="anonymous"
    ></script>

    <script
      async
      src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"
    ></script>

    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.140.1/build/three.module.js",
          "controls": "https://unpkg.com/three@0.140.1/examples/jsm/controls/OrbitControls.js",
          "loader": "https://unpkg.com/three@0.140.1/examples/jsm/loaders/GLTFLoader.js",
          "stats": "https://unpkg.com/three@0.140.1/examples/jsm/libs/stats.module.js"
        }
      }
    </script>

    <script type="module">
      import * as THREE from "three";
      import { OrbitControls } from "controls";
      import { GLTFLoader } from "loader";
      import Stats from "stats";

      // SCENE
      const scene = new THREE.Scene();

      // CAMERA
      const camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );

      // RENDERER
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;

      // STATS
      let container, stats;

      container = document.createElement("div");
      document.body.appendChild(container);
      stats = new Stats();
      container.appendChild(stats.dom, renderer.domElement);

      // CONTROLS
      const controls = new OrbitControls(camera, renderer.domElement);

      // LOADER
      const loader = new GLTFLoader();

      // RESIZE HAMDLER
      export function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }
      window.addEventListener("resize", onWindowResize);

      // INIT CAMERA
      camera.position.z = 25;
      camera.position.x = 3;
      camera.position.y = 6;
      camera.lookAt(0, 0, -20);

      // INIT HEMISPHERE LIGHT
      scene.add(new THREE.AmbientLight(0xffffff, 0.5));

      // SCENE
      scene.background = new THREE.Color(0xfab74b);

      // FLOOR
      const plane = new THREE.Mesh(
        new THREE.PlaneGeometry(500, 500, 32),
        new THREE.MeshPhongMaterial({ color: 0xfab74b })
      );
      plane.rotation.x = -Math.PI / 2;
      plane.receiveShadow = true;
      scene.add(plane);

      // PLAYER
      let player;
      loader.load("player/player.gltf", function (gltf) {
        player = gltf.scene;
        player.position.set(3, 0, 5);
        player.receiveShadow = true;
        player.castShadow = true;
        player.scale.set(5, 5, 5);
        scene.add(player);
      });

      // CONE
      const cone = new THREE.Mesh(
        new THREE.ConeGeometry(2, 5, 64),
        new THREE.MeshPhongMaterial({ color: 0xdbde40 })
      );
      cone.position.set(7, 2.5, 2.7);
      cone.receiveShadow = true;
      cone.castShadow = true;
      scene.add(cone);

      // CYLINDER
      const cylinder = new THREE.Mesh(
        new THREE.CylinderGeometry(1, 1, 6, 64),
        new THREE.MeshPhongMaterial({ color: 0x3ea34c })
      );
      cylinder.position.set(3, 3, 2.7);
      cylinder.receiveShadow = true;
      cylinder.castShadow = true;
      scene.add(cylinder);

      // TORUS
      const torus = new THREE.Mesh(
        new THREE.TorusGeometry(2, 0.5, 64, 64),
        new THREE.MeshPhongMaterial({ color: 0x2a7ab0 })
      );
      torus.position.set(-0.5, 2.5, 2.7);
      torus.rotateY(2.5);
      torus.receiveShadow = true;
      torus.castShadow = true;
      scene.add(torus);

      // DIRECTIONAL LIGHT
      const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
      directionalLight.position.x += 20;
      directionalLight.position.y += 20;
      directionalLight.position.z += 20;
      directionalLight.castShadow = true;
      directionalLight.shadow.mapSize.width = 4096;
      directionalLight.shadow.mapSize.height = 4096;
      const d = 25;
      directionalLight.shadow.camera.left = -d;
      directionalLight.shadow.camera.right = d;
      directionalLight.shadow.camera.top = d;
      directionalLight.shadow.camera.bottom = -d;
      scene.add(directionalLight);

      scene.add(new THREE.CameraHelper(directionalLight.shadow.camera));

      // SPOT LIGHT
      // const spotLight = new THREE.SpotLight( 0xffffff );
      // spotLight.position.set( 20, 15, 20 );
      // spotLight.castShadow = true;
      // spotLight.shadow.mapSize.width = 4096;
      // spotLight.shadow.mapSize.height = 4096;
      // scene.add(spotLight)

      // POINT LIGHT
      // const light1 = new THREE.PointLight( 0xff0000, 1, 100 );
      // light1.position.set( 20, 20, 20 );
      // light1.castShadow = true;
      // light1.shadow.mapSize.width = 4096;
      // light1.shadow.mapSize.height = 4096;
      // scene.add( light1 );

      // const light2 = new THREE.PointLight( 0x00ff00, 1, 100 );
      // light2.position.set( 20, 20, 20 );
      // light2.castShadow = true;
      // light2.shadow.mapSize.width = 4096;
      // light2.shadow.mapSize.height = 4096;
      // scene.add( light2 );

      // ANIMATE
      function animate() {
        // TARGET
        // const time = Date.now() * 0.0005;
        // directionalLight.position.x = Math.sin(time * 0.7) * 20;
        // directionalLight.position.z = Math.cos(time * 0.7) * 20;

        // spotLight.position.x = Math.sin(time * 0.7) * 20;
        // spotLight.position.z = Math.cos(time * 0.7) * 20;

        // light1.position.x = Math.sin(time) * 20;
        // light1.position.z = Math.sin(time) * 20;
        // light2.position.x = Math.cos(time) * -20;
        // light2.position.z = Math.cos(time) * 20;

        renderer.render(scene, camera);
        requestAnimationFrame(animate);
        stats.update();
      }
      document.body.appendChild(renderer.domElement);
      animate();
    </script>
  </body>
</html>
